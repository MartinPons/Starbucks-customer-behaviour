from matplotlib import pyplot as plt
import seaborn as sns
import pandas as pd
import itertools


OFFERS_PAL_DICT = {'Discount': "#4F6BA7",
                'Bogo': "#84A8C7",
                'Informational': "#BBBFA2"}

def group_and_smooth(offers, group_vars):
    '''Groups categoric variables from the offers DataFrame, including offer_type, averages the "completed" variable
     generating a ratio of completion. Then smoothes it applying a rolling average average of order 7 grouping by categorical
     variables


     INPUTS
        - offers (DataFrame): data frame with the offers to analyze
         - group_vars (list): a list with the names of the variables to group and average

     RETURNS

         A DataFrame with the variables aggregated
     '''

    # grouping and average to obtain the completion rate
    group_vars = ["offer_type"] + group_vars
    df_group = offers.groupby(group_vars).agg({"completed": "mean"}).reset_index()

    # get the categorical variables to determine the grouping window to smooth the completion rate
    cat_vars = list(df_group.dtypes[df_group.dtypes == "object"].index)

    df_group['mm7'] = df_group.groupby(cat_vars).completed.apply(lambda x: x.rolling(7).mean().shift(-3))

    df_group.reset_index(inplace=True)
    df_group.drop("index", axis=1, inplace=True)

    return df_group


def plot_completion_lines(data, cont_var, title, x_label, cat_var=None, palette=["#4F6BA7", "#84A8C7", "#BBBFA2"],
                          linewidth=1):
    '''Plots the smoothed completion rate generated by group_and_smooth, against a numeric variable and separated in different
    lines by a categorical variable. There is one plot for every offer type. If no categorical variable is provided. Lines are grouped
    by offer_type

    INPUTS

        - data (DataFrame): the data to plot the model
        - cont_var (string): numeric variable to plot the completion rate against
        - title (string): plot title
        - x_label (string): title for the x axis,
        - palette (list): list of length equal to the number of distinct values in cat_var, to color the lines.
        - cat_var (string): categorical variable in data to group the lines in the plot
        - linewidth: with of the lines

     RETURNS
         - A completion rate plot

        '''

    # if not categorical variable is provided, offer_type will be the variable to group the lines and determine the colors
    hue_var = ["offer_type", cat_var][(cat_var is not None) * 1]

    g = sns.FacetGrid(data,
                      col="offer_type",
                      hue=hue_var,
                      palette=palette,
                      col_order=["Informational", "Bogo", "Discount"],
                      aspect=1,
                      height=3.2,
                      sharey=True)

    g.map(sns.lineplot, cont_var, "mm7", label="Completion rate", linewidth=linewidth)

    # place legend and title depending of if we have facets or not
    if cat_var is None:
        g.map(sns.lineplot, cont_var, "completed", alpha=0.5, size=2)
        plt.legend()
        plt.suptitle(title, y=1.05)

    else:
        plt.legend(ncol=3, bbox_to_anchor=(-0.15, 1.35))
        plt.suptitle(title, y=1.2)

    # theme and formatting
    g.set(ylabel="Completion rate")
    g.set_titles("{col_name}", size=13)
    g.set_xlabels("")
    plt.text(0.5, 0.05, x_label, ha='center', va='center', transform=g.fig.transFigure)

    for ax in g.axes.flat:
        ax.xaxis.set_ticks_position('none')
        ax.yaxis.set_ticks_position('none')
        ax.spines['bottom'].set_color('#D0D0D0')
        ax.spines['left'].set_color('#D0D0D0')

    for i, ax in enumerate(g.axes.flat):
        if i > 0:
            ax.yaxis.set_ticks_position('none')
            ax.spines['left'].set_visible(False)

    return g


def plot_completion_by_categorical(offers, x_var, title, width=1, ax=None, legend=True, join=False):
    '''Plots the completion rate against a categorical variable grouped by offer_type as a pointplot. The data must contain the
    "completed field with values 0 or 1, and the offer_type field"

    INPUTS

    - data (Dataframe): the data to plot
    - title (str): plot title
    - width (float): dot width
    - ax (int): number of axs
    - legend (bool): determines if a legend has to be drawn
    - join (bool): determines if lines joining the points have to be drawn

    OUTPUT

    A completion rate plot against a categorical variable
    '''

    sns.set_context("notebook")

    # if there are not facets figure and ax are stablished explicitly
    if ax is None:
        fig, ax = plt.subplots()

    # pointplot
    g = sns.pointplot(data=offers,
                      x=x_var,
                      y="completed",
                      hue="offer_type",
                      edgecolor="red",
                      markers="D",
                      linestyles="dotted",
                      aspect=1.3,
                      height=4.5,
                      palette=OFFERS_PAL_DICT,
                      width=width,
                      join=join,
                      errwidth=2,
                      legend=legend,
                      errorbar=None,
                      ci=None,
                      ax=ax)

    # theme and format
    g.set_title(title)
    g.set_ylabel("Completion rate")
    g.legend(title=None)

    g.xaxis.set_ticks_position('none')
    g.yaxis.set_ticks_position('none')

    g.spines['left'].set_color('#999999')
    g.spines['bottom'].set_color('#999999')
    g.set_xlabel(None)

    sns.despine()

    return g


def plot_prediction_groups(preds_data, offer_type, overall_prob):
    '''PLots probability predictions from a DataFrame of prediction agains a categorical variable as a pointplot.
    The theme of the plot is designed to represent the probability of completion by offer type

    INTPUTS

    - preds_data (DataFrame): data frame with a numeric "preds" column, a categorical "group" color and an offer_type column
    - offer_type (str): the name of the offer type as it is in the offer_type field of the pred_data
    - overall_prob (float): probability of completion for the overall data

    RETURNS

    A plot of probability of completion against a categorical variable
    '''

    # set figure parmeters
    sns.set(style="white", font="TW Cen MT Condensed Extra Bold",
            rc={"text.color": "#AF9A7D"})

    fig, ax = plt.subplots(figsize=(8, 8))

    # vertical line for the overall probability of completion
    ax.axvline(overall_prob, color="#B6AFAF", linewidth=1.2, alpha=1, linestyle="--")
    ax.text(overall_prob - 0.02, 1,
            "Overall likehood of\ncompletion for\n" + offer_type.upper() + " offers",
            rotation=0,
            va='center',
            ha="right",
            fontsize=9,
            color="#7C6C58")

    # scatter plot with the probability of completion against the group variable
    sns.scatterplot(data=preds_data.loc[preds_data.offer_type == offer_type],
                    x="preds",
                    y="group",
                    color=OFFERS_PAL_DICT[offer_type],
                    ax=ax,
                    alpha=0.8,
                    size="n_offers",
                    legend=False)

    # Theme and format
    offer_type = offer_type.upper()

    ax.set_xlim([0, 1])
    ax.yaxis.set_tick_params(labelsize=9)

    ax.set(ylabel="")
    plt.title("Predicted probability of completion for " + offer_type + " offers", size=13, y=1.03)
    plt.suptitle("(Radius of the circles are proportional to number of offers in the group)",
                 fontsize=9.5,
                 y=0.92,
                 x=0.65,
                 color="#8c7d69")

    ax.set_xlabel("Prob. of completion")

    ax.xaxis.set_ticks_position('none')
    ax.yaxis.set_ticks_position('none')
    ax.spines['bottom'].set_color('#D0D0D0')
    ax.spines['left'].set_color('none')

    ax.yaxis.set_ticks_position('none')
    ax.spines['left'].set_visible(False)

    sns.despine()

    plt.subplots_adjust(left=0.4, right=0.9, bottom=0.1, top=0.9)


def expand_grid(*args, var_names):
    """
    Takes any number of iterables as arguments
    and returns a data frame with the cartessian product.

    INPUTS

     - *args: a number of iterables from which values are crossed
     - var_names: the column names for the DataFrame generated

     RETURNS

         A DataFrame in which the rows contain every single combination of values resulting crossing the iterables in *args
    """

    return pd.DataFrame(columns=var_names, data=list(itertools.product(*args)))